---
import Cpp from './icons/programming-languages/cpp.astro';
import Dotnet from './icons/programming-languages/dotnet.astro';
import Go from './icons/programming-languages/go.astro';
import Java from './icons/programming-languages/java.astro';
import Javascript from './icons/programming-languages/javascript.astro';
import Python from './icons/programming-languages/python.astro';
import Rust from './icons/programming-languages/rust.astro';
import Swift from './icons/programming-languages/swift.astro';
import Typescript from './icons/programming-languages/typescript.astro';
---

<div class="floating-languages-container" id="floating-container"></div>

<template id="bubble-templates">
  <div class="bubble-template" data-lang="javascript">
    <Javascript class="icon" />
  </div>
  <div class="bubble-template" data-lang="python">
    <Python class="icon" />
  </div>
  <div class="bubble-template" data-lang="typescript">
    <Typescript class="icon" />
  </div>
  <div class="bubble-template" data-lang="rust">
    <Rust class="icon" />
  </div>
  <div class="bubble-template" data-lang="cpp">
    <Cpp class="icon" />
  </div>
  <div class="bubble-template" data-lang="java">
    <Java class="icon" />
  </div>
  <div class="bubble-template" data-lang="go">
    <Go class="icon" />
  </div>
  <div class="bubble-template" data-lang="swift">
    <Swift class="icon" />
  </div>
  <div class="bubble-template" data-lang="dotnet">
    <Dotnet class="icon" />
  </div>
</template>

<style>
  .floating-languages-container {
    position: absolute;
    inset: 0;
    overflow: hidden;
    pointer-events: none;
    z-index: 5;
  }

  .bubble {
    position: absolute;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s ease;
  }

  .bubble:hover {
    transform: scale(1.15);
  }

  .bubble :global(.icon) {
    width: 100%;
    height: 100%;
    opacity: 0.5;
    filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.5));
  }

  /* Tamaños más pequeños */
  .bubble {
    width: 55px;
    height: 55px;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .bubble {
      width: 40px !important;
      height: 40px !important;
    }
  }

  @media (max-width: 480px) {
    .bubble {
      width: 35px !important;
      height: 35px !important;
    }
  }
</style>

<script>
  class BubblePhysics {
    private bubbles: HTMLElement[] = [];
    private velocities: Map<HTMLElement, { vx: number; vy: number }> = new Map();
    private container: HTMLElement | null = null;
    private animationId: number | null = null;
    private readonly MIN_BUBBLES = 13;
    private readonly MAX_BUBBLES = 20;
    private initialized = false;
    private resizeTimeout: number | null = null;
    private readonly STORAGE_KEY = 'floating-bubbles-state';

    init() {
      this.container = document.getElementById('floating-container');
      if (!this.container || this.initialized) return;

      // Intentar restaurar estado previo
      const savedState = this.loadState();
      if (savedState) {
        this.restoreState(savedState);
      } else {
        this.createBubbles();
      }

      this.animate();
      this.initialized = true;

      // Listener para resize con debounce
      window.addEventListener('resize', this.handleResize);

      // Guardar estado periódicamente
      setInterval(() => this.saveState(), 1000);
    }

    private handleResize = () => {
      if (this.resizeTimeout) {
        clearTimeout(this.resizeTimeout);
      }

      // Debounce para evitar llamadas excesivas
      this.resizeTimeout = window.setTimeout(() => {
        this.adjustBubblesForScreenSize();
        this.adjustBubblesPosition();
      }, 100);
    };

    private createBubbles() {
      if (!this.container) return;

      const template = document.getElementById('bubble-templates') as HTMLTemplateElement;
      if (!template) return;

      const templates = Array.from(template.content.querySelectorAll('.bubble-template'));
      const containerRect = this.container.getBoundingClientRect();

      // Determinar cantidad de burbujas según tamaño de pantalla
      let targetCount = this.MIN_BUBBLES;
      if (window.innerWidth > 1024) {
        targetCount = this.MAX_BUBBLES;
      } else if (window.innerWidth > 768) {
        targetCount = Math.floor((this.MIN_BUBBLES + this.MAX_BUBBLES) / 2);
      }

      // Crear burbujas duplicando templates si es necesario
      const bubblesNeeded = targetCount;
      for (let i = 0; i < bubblesNeeded; i++) {
        const templateIndex = i % templates.length;
        const templateNode = templates[templateIndex];
        const bubble = templateNode.cloneNode(true) as HTMLElement;

        bubble.classList.remove('bubble-template');
        bubble.classList.add('bubble');

        // Mantener atributo data-lang
        const lang = templateNode.getAttribute('data-lang');
        if (lang) {
          bubble.setAttribute('data-lang', lang);
        }

        // Posición aleatoria inicial
        const maxX = containerRect.width - 55;
        const maxY = containerRect.height - 55;
        const randomX = Math.random() * maxX;
        const randomY = Math.random() * maxY;

        bubble.style.left = `${randomX}px`;
        bubble.style.top = `${randomY}px`;

        // Velocidad aleatoria más lenta
        const speed = 0.15 + Math.random() * 0.15; // 0.15 a 0.3 (más lento)
        const angle = Math.random() * Math.PI * 2;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;

        this.velocities.set(bubble, { vx, vy });
        this.container!.appendChild(bubble);
        this.bubbles.push(bubble);
      }
    }

    private adjustBubblesForScreenSize() {
      if (!this.container) return;

      // Determinar cantidad objetivo según pantalla
      let targetCount = this.MIN_BUBBLES;
      if (window.innerWidth > 1024) {
        targetCount = this.MAX_BUBBLES;
      } else if (window.innerWidth > 768) {
        targetCount = Math.floor((this.MIN_BUBBLES + this.MAX_BUBBLES) / 2);
      }

      const currentCount = this.bubbles.length;

      if (currentCount < targetCount) {
        // Agregar burbujas
        const template = document.getElementById('bubble-templates') as HTMLTemplateElement;
        if (!template) return;
        const templates = Array.from(template.content.querySelectorAll('.bubble-template'));
        const containerRect = this.container.getBoundingClientRect();

        for (let i = currentCount; i < targetCount; i++) {
          const templateIndex = i % templates.length;
          const templateNode = templates[templateIndex];
          const bubble = templateNode.cloneNode(true) as HTMLElement;

          bubble.classList.remove('bubble-template');
          bubble.classList.add('bubble');

          // Mantener atributo data-lang
          const lang = templateNode.getAttribute('data-lang');
          if (lang) {
            bubble.setAttribute('data-lang', lang);
          }

          const maxX = containerRect.width - 55;
          const maxY = containerRect.height - 55;
          bubble.style.left = `${Math.random() * maxX}px`;
          bubble.style.top = `${Math.random() * maxY}px`;

          const speed = 0.15 + Math.random() * 0.15;
          const angle = Math.random() * Math.PI * 2;
          this.velocities.set(bubble, {
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed
          });

          this.container!.appendChild(bubble);
          this.bubbles.push(bubble);
        }
      } else if (currentCount > targetCount) {
        // Remover burbujas
        const toRemove = currentCount - targetCount;
        for (let i = 0; i < toRemove; i++) {
          const bubble = this.bubbles.pop();
          if (bubble) {
            this.velocities.delete(bubble);
            bubble.remove();
          }
        }
      }
    }

    private adjustBubblesPosition() {
      if (!this.container) return;

      const containerRect = this.container.getBoundingClientRect();

      // Ajustar posiciones de burbujas que están fuera de los límites
      this.bubbles.forEach((bubble) => {
        const rect = bubble.getBoundingClientRect();
        const currentLeft = rect.left - containerRect.left;
        const currentTop = rect.top - containerRect.top;

        let newLeft = currentLeft;
        let newTop = currentTop;

        // Si la burbuja está fuera de los límites, ajustarla dentro
        if (currentLeft < 0) {
          newLeft = 0;
        } else if (currentLeft + rect.width > containerRect.width) {
          newLeft = containerRect.width - rect.width;
        }

        if (currentTop < 0) {
          newTop = 0;
        } else if (currentTop + rect.height > containerRect.height) {
          newTop = containerRect.height - rect.height;
        }

        // Solo actualizar si cambió
        if (newLeft !== currentLeft || newTop !== currentTop) {
          bubble.style.left = `${newLeft}px`;
          bubble.style.top = `${newTop}px`;
        }
      });
    }

    private animate = () => {
      this.updatePositions();
      this.checkCollisions();
      this.animationId = requestAnimationFrame(this.animate);
    };

    private updatePositions() {
      if (!this.container) return;

      const containerRect = this.container.getBoundingClientRect();

      this.bubbles.forEach((bubble) => {
        const velocity = this.velocities.get(bubble);
        if (!velocity) return;

        const rect = bubble.getBoundingClientRect();
        const containerLeft = containerRect.left;
        const containerTop = containerRect.top;

        const currentLeft = rect.left - containerLeft;
        const currentTop = rect.top - containerTop;

        let newLeft = currentLeft + velocity.vx;
        let newTop = currentTop + velocity.vy;

        // Colisión con bordes
        if (newLeft <= 0 || newLeft + rect.width >= containerRect.width) {
          velocity.vx *= -1;
          newLeft = Math.max(0, Math.min(newLeft, containerRect.width - rect.width));
        }

        if (newTop <= 0 || newTop + rect.height >= containerRect.height) {
          velocity.vy *= -1;
          newTop = Math.max(0, Math.min(newTop, containerRect.height - rect.height));
        }

        bubble.style.left = `${newLeft}px`;
        bubble.style.top = `${newTop}px`;
      });
    }

    private checkCollisions() {
      for (let i = 0; i < this.bubbles.length; i++) {
        for (let j = i + 1; j < this.bubbles.length; j++) {
          const bubble1 = this.bubbles[i];
          const bubble2 = this.bubbles[j];

          const rect1 = bubble1.getBoundingClientRect();
          const rect2 = bubble2.getBoundingClientRect();

          const dx = (rect1.left + rect1.width / 2) - (rect2.left + rect2.width / 2);
          const dy = (rect1.top + rect1.height / 2) - (rect2.top + rect2.height / 2);
          const distance = Math.sqrt(dx * dx + dy * dy);
          const minDistance = (rect1.width + rect2.width) / 2;

          if (distance < minDistance) {
            const vel1 = this.velocities.get(bubble1)!;
            const vel2 = this.velocities.get(bubble2)!;

            const tempVx = vel1.vx;
            const tempVy = vel1.vy;
            vel1.vx = vel2.vx;
            vel1.vy = vel2.vy;
            vel2.vx = tempVx;
            vel2.vy = tempVy;

            const overlap = minDistance - distance;
            const angle = Math.atan2(dy, dx);
            const moveX = Math.cos(angle) * overlap / 2;
            const moveY = Math.sin(angle) * overlap / 2;

            const containerRect = this.container!.getBoundingClientRect();
            const left1 = rect1.left - containerRect.left;
            const top1 = rect1.top - containerRect.top;
            const left2 = rect2.left - containerRect.left;
            const top2 = rect2.top - containerRect.top;

            bubble1.style.left = `${left1 + moveX}px`;
            bubble1.style.top = `${top1 + moveY}px`;
            bubble2.style.left = `${left2 - moveX}px`;
            bubble2.style.top = `${top2 - moveY}px`;
          }
        }
      }
    }

    private saveState() {
      if (!this.container) return;

      const state = {
        bubbles: this.bubbles.map((bubble) => {
          const velocity = this.velocities.get(bubble);
          const lang = bubble.getAttribute('data-lang') || bubble.querySelector('.bubble-template')?.getAttribute('data-lang');
          return {
            lang,
            left: bubble.style.left,
            top: bubble.style.top,
            vx: velocity?.vx || 0,
            vy: velocity?.vy || 0
          };
        }),
        timestamp: Date.now()
      };

      try {
        sessionStorage.setItem(this.STORAGE_KEY, JSON.stringify(state));
      } catch (e) {
        // Ignorar errores de storage
      }
    }

    private loadState() {
      try {
        const stored = sessionStorage.getItem(this.STORAGE_KEY);
        if (!stored) return null;

        const state = JSON.parse(stored);

        // Expirar estado después de 5 minutos
        if (Date.now() - state.timestamp > 5 * 60 * 1000) {
          sessionStorage.removeItem(this.STORAGE_KEY);
          return null;
        }

        return state;
      } catch (e) {
        return null;
      }
    }

    private restoreState(state: any) {
      if (!this.container) return;

      const template = document.getElementById('bubble-templates') as HTMLTemplateElement;
      if (!template) return;

      const templates = Array.from(template.content.querySelectorAll('.bubble-template'));

      state.bubbles.forEach((bubbleData: any) => {
        const templateNode = templates.find(t => t.getAttribute('data-lang') === bubbleData.lang);
        if (!templateNode) return;

        const bubble = templateNode.cloneNode(true) as HTMLElement;
        bubble.classList.remove('bubble-template');
        bubble.classList.add('bubble');
        bubble.setAttribute('data-lang', bubbleData.lang);

        bubble.style.left = bubbleData.left;
        bubble.style.top = bubbleData.top;

        this.velocities.set(bubble, {
          vx: bubbleData.vx,
          vy: bubbleData.vy
        });

        this.container!.appendChild(bubble);
        this.bubbles.push(bubble);
      });
    }

    destroy() {
      this.saveState();

      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
      if (this.resizeTimeout) {
        clearTimeout(this.resizeTimeout);
      }
      window.removeEventListener('resize', this.handleResize);
    }
  }

  const physics = new BubblePhysics();

  document.addEventListener('DOMContentLoaded', () => {
    physics.init();
  });

  document.addEventListener('astro:before-swap', () => {
    physics.destroy();
  });
</script>
